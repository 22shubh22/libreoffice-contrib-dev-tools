= Clang libtooling-based rename

== This tool vs clang-rename

This tool is similar to clang-rename, though there are a number of differences.

Pros:

- old name can be a simple qualified name, no need to manually specify a byte
  offset
- rename handles ctor initializer list, too
- handles macros, even nested ones
- comes with a wrapper to do fully automatic rewriting

Cons:

- handles only rename of data members and member functions so far
- only tested with clang 3.5/3.7

== Hello world

Example usage:

----
bin/rename -dump -old-name=C::nX -new-name=m_nX test.cxx --
----

If you get missing includes:

----
ln -s /usr/lib64
----

== Searching for the members to rename

Build the LibreOffice build with some additional parameters, like:

-----
make <build-param> COMPILER_EXTERNAL_TOOL=1 CXX='<full-path>/bin/find-unprefixed-members-wrapper /usr/bin/clang++' RENAME_ARGS="-class-name=<class-name>"
-----

- <build-param> is what you'd normally provide to make, like sw.build or
  build-nocheck.
- <class-name> is the class name you are interested in calling the 'find
  uprefixed' machinery to operate on.

The build will start, and at the first successful find of the class that has
the members to rename, it will output them, and stop the build.  They are also
stored in /tmp/rename.csv.

== Build system integration

LibreOffice integration example with csv handling, provided that:

- rename-wrapper is in your PATH
- rename.csv is something like in your HOME:

----
C::nX,m_nX
C::nY,m_nY
----

Then run:

----
make -sr -j8 COMPILER_EXTERNAL_TOOL=1 FORCE_COMPILE_ALL=1 CCACHE_PREFIX=rename-wrapper RENAME_ARGS="-csv=$HOME/rename.csv"
----

Once the rewriting is done, you can overwrite the original files with the .new-prefix ones with:

----
for i in $(find . -name "*.new-prefix"); do mv -f $i ${i%%.new-prefix}; done
----

// vim: ft=asciidoc
