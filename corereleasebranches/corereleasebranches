#!/bin/bash

REPODIR=`readlink -f $1`

OLDREPONAMES="artwork base bootstrap calc components extensions extras filters impress libs-core libs-extern-sys libs-extern libs-gui postprocess sdk testing ure writer" 

BISECTFUNCTOR=`mktemp`
chmod u+x $BISECTFUNCTOR
cat > $BISECTFUNCTOR <<EOF
#!/bin/bash
for file in \`cd \$1 && find . -type f -not -path "./.git*"\`
do
    if [ -e \$file ]
    then
        if [ ! \$file -nt \$1/\$file ]
        then
            exit 1
        fi
    fi
done
exit 0
EOF

function recreate_repotag {
    local REPO=$1
    local TAGTOFIND=$2
    local LOWERBOUND=$3
    local UPPERBOUND=$4
    if [ -n "`cd $REPODIR/core && git tag|grep ${REPO}_${TAGTOFIND}`" ]
    then
        echo "tag ${REPO}_${TAGTOFIND} exists already in core."
        return
    fi
    if [ -z "`cd $REPODIR/$REPO && git tag|grep ${TAGTOFIND}`" ]
    then
        echo "tag ${TAGTOFIND} also missing in repo ${REPO}."
        return
    fi
    echo "searching for $TAGTOFIND from $REPO between $LOWERBOUND and $UPPERBOUND"
    pushd $REPODIR/core > /dev/null
    #find the first commit with any file younger than in the reference
    if [ "`git rev-list --no-walk ${REPO}_$LOWERBOUND`" = "`git rev-list --no-walk ${REPO}_${UPPERBOUND}`" ]
    then
        git tag ${REPO}_${TAGTOFIND} ${REPO}_$LOWERBOUND
    else
        `cd $REPODIR/$REPO && git checkout $TAGTOFIND`
        git bisect reset
        git bisect start ${REPO}_${UPPERBOUND} ${REPO}_${LOWERBOUND}^
        git bisect skip 575c02a34623b3bb3e596708cbc917cbe2a4eba6
        git bisect run $BISECTFUNCTOR $REPODIR/$REPO
        if [ "$?" -eq "0" ]
        then
            git tag ${REPO}_${TAGTOFIND} `git rev-list --bisect-all ^${REPO}_${LOWERBOUND} ${HEAD}|grep dist=1|tail -n1|cut -f1 -d\ `
        else
            exit 1
        fi
        git bisect reset
    fi
    popd > /dev/null
}

function premerge_fixes {
    pushd $REPODIR/core > /dev/null
    rm .git/hooks/*
    git tag writer_LIBREOFFICE_3_3_0_1 520eb9a251e557ffbebfc79deb5ee0cb55600d9e
    git tag postprocess_LIBREOFFICE_3_3_0_1 98bb7da5f26a1644397dbe73d35e0a083e45da85
    git tag -d filters_feature/gnumake4_writerfilter_base
    git tag -d filters_feature/gnumake4_writerfilter_head
    for repo in $OLDREPONAMES
    do
        #recreate_repotag ${repo} OOO_BUILD_3_2_98_1 OOO_BUILD_3_2_98_0 LIBREOFFICE_3_3_0_1
        #recreate_repotag ${repo} LIBREOFFICE_3_2_99_1 OOO_BUILD_3_2_98_1 LIBREOFFICE_3_3_0_1

        #recreate_repotag ${repo} libreoffice-3.3.1.2 libreoffice-3.3.0.3 libreoffice-3.3.2.1
        #recreate_repotag ${repo} libreoffice-3.3.0.4 libreoffice-3.3.0.3 libreoffice-3.3.2.1
        #recreate_repotag ${repo} libreoffice-3.3.1.1 libreoffice-3.3.0.4 libreoffice-3.3.1.2

        #recreate_repotag ${repo} libreoffice-3.3.3.1 libreoffice-3.3.1.2 libreoffice-3.4.0.1
        #recreate_repotag ${repo} libreoffice-3.3.4.1 libreoffice-3.3.3.1 libreoffice-3.4.0.1
        #recreate_repotag ${repo} libreoffice-3.3.2.2 libreoffice-3.3.2.1 libreoffice-3.3.3.1

        git tag -d ${repo}_ooo/DEV300_last_svn_milestone
    done
    popd > /dev/null
}

function postmerge_fixes {
    pushd $REPODIR/core > /dev/null
    rm .git/hooks/*
    git tag libreoffice-3.2.99.1 LIBREOFFICE_3_2_99_1
    git tag -d LIBREOFFICE_3_2_99_1
    git tag libreoffice-3.2.99.2 LIBREOFFICE_3_2_99_2
    git tag -d LIBREOFFICE_3_2_99_2
    git tag libreoffice-3.2.99.3 LIBREOFFICE_3_2_99_3
    git tag -d LIBREOFFICE_3_2_99_3
    git tag -d linux-build-fridrich-20100930
    git tag libreoffice-3.3.0.1 LIBREOFFICE_3_3_0_1
    git tag -d LIBREOFFICE_3_3_0_1
    git branch -D LIBREOFFICE
    git branch -D LO-BASE-INTEGRATION-DEV300
    git branch -D OOO_BUILD
    git branch -D linux-build-fridrich-20100930
    git branch -D ooo/OOO310
    git branch -D ooo/OOO320
    git branch -D ooo/OOO330
    git tag ooo/DEV300_last_svn_milestone ooo/DEV300_m63
    popd > /dev/null
}

function tag_to_notes {
    local TAG=$1
    pushd $REPODIR/core > /dev/null
    local OLDREPOTAGS=`for repo in $OLDREPONAMES;do echo ${repo}_${TAG}; done`
    # -remove split repo tags
    # -write split repo notes replacing the tag
    for repotag in $OLDREPOTAGS
    do
        echo "tag to note: $repotag"
        if [ -n "`git tag|grep ${repotag}`" ]
        then
            git notes append -m "split repo tag: ${repotag}" `git rev-list --no-walk ${repotag}`
            git tag -d ${repotag}
        fi
    done
    popd > /dev/null
}

function merge_tag {
    local TAG=$1
    # -dont try to create an existing tag
    if [ -z "`git tag|grep ${TAG}`" ]
    then
        return
    fi
    pushd $REPODIR/core > /dev/null
    local OLDREPOTAGS=`for repo in $OLDREPONAMES;do echo ${repo}_${TAG}; done`
    # -check if all repo tags are there
    local MISSINGTAGS=
    for repotag in $OLDREPOTAGS
    do
        if [ -z "`git tag|grep ${repotag}`" ]
        then
            MISSINGTAGS+=" $repotag"
        fi
    done 
    if [ -n "$MISSINGTAGS" ]
    then
        echo "Not mergeing tag $TAG because $MISSINGTAGS are missing!"
        SKIPPEDTAGS="$SKIPPEDTAGS $TAG"
        ALLMISSINGTAGS="$ALLMISSINGTAGS $MISSINGTAGS"
        popd > /dev/null
        return
    fi
    # -if so merge them in the current branch
    git clean -df > /dev/null
    git merge --strategy ours --no-commit $OLDREPOTAGS
    rm -rf *
    for repo in $OLDREPONAMES
    do
        git archive --format=tar ${repo}_${TAG}|tar -x
    done
    # -use .gitignore and .gitattributes from master
    git checkout master -- .gitignore .gitattributes
    git add --all
    # -use time of the last commit on all branches
    COMMITTIME=`git rev-list --no-walk --timestamp --date-order $OLDREPOTAGS --max-count=1|cut -f1 -d\ `
    GIT_AUTOR_DATE="$COMMITTIME" GIT_COMMITER_DATE="$COMMITTIME" git commit -m "merged tag $TAG" --date=$COMMITTIME
    # -tag merged commit
    git tag $TAG
    popd > /dev/null
}

#creates a merged branch
function create_branch {
    echo "creating branch $1 with tags $2"
    local BRANCHNAME=$1
    local TAGS=$2
    [ -n "$BRANCHNAME" ] || return
    [ -n "$TAGS" ] || return
    local BOOTSTRAPTAGS=""
    pushd $REPODIR/core > /dev/null
    for tag in $TAGS
    do
        BOOTSTRAPTAGS="$BOOTSTRAPTAGS bootstrap_$tag"
    done
    #sort tags for this branch topological
    local ORDEREDBOOTSTRAPHASHES=`git rev-list --no-walk --topo-order --reverse $BOOTSTRAPTAGS`
    local BRANCHCREATED=
    for hash in $ORDEREDBOOTSTRAPHASHES
    do
        local TAG=`git name-rev --tags --name-only $hash|sed -e s/^bootstrap_// -e s/..$//`
        echo "working on bootstrap commit $hash which is $TAG"
        if [ -z "$BRANCHCREATED" ]
        then
            #-if the first tag has already been created just start from there
            #-otherwise start from bootstrap
            if [ -n "`git tag|grep ${TAG}`" ]
            then
                echo "basetag $TAG for branch $BRANCHNAME does not exist yet."
                if [ -n "`git tag|grep bootstrap_$TAG`" ]
                then
                    echo "creating branch from bootstrap."
                    git checkout -b $BRANCHNAME bootstrap_$TAG
                    echo "merge tag $TAG"
                    merge_tag $TAG
                    BRANCHCREATED=T
                else
                    echo "missing bootstrap tag bootstrap_$TAG for creating branch $BRANCHNAME"
                fi
            else
                echo "basetag $TAG for branch $BRANCHNAME has already been created."
                git checkout -b $BRANCHNAME $TAG
                BRANCHCREATED=T
            fi
        else
            #-we already have a branch so we just pump out the merged tags as commits on it
            merge_tag $TAG
        fi
    done
    popd > /dev/null
}


# find and sort all relevant tags
# ensure the basebranches get created first
FINDREPOBRANCHES=`mktemp`
TAGSFORBRANCH=`mktemp`
cat > $FINDREPOBRANCHES <<EOF
    BEGIN {
        RS=" ";
        FS=".";
        TAGSFORBRANCH["ooo/OOO320"] = "ooo/DEV300_m60";
        TAGSFORBRANCH["ooo/OOO330"] = "ooo/DEV300_m84";
        TAGSFORBRANCH["ooo/DEV300_last_svn_milestone"] = "ooo/DEV300_m63";
        TAGSFORBRANCH["libreoffice-3-4-2"] = "libreoffice-3.4.1.1";
        TAGSFORBRANCH["libreoffice-3-4-1"] = "libreoffice-3.4.0.1";
        TAGSFORBRANCH["libreoffice-3-3-3"] = "libreoffice-3.3.2.1";
        TAGSFORBRANCH["libreoffice-3-3-2"] = "libreoffice-3.3.1.1";
        TAGSFORBRANCH["libreoffice-3-3-1"] = "LIBREOFFICE_3.3.1.1";
    }
    /^libreoffice-.*/ {
        MAJOR=\$1 "-" \$2
        MINOR=\$1 "-" \$2 "-" \$3
        RC=\$1 "." \$2 "." \$3 "." \$4
        # libreoffice-3.3 is way undertagged for now so we leave it out
        # we can make a run for it later, when there are enough tags
        # (or at least the release finals)
        if(\$4=="1")
            TAGSFORBRANCH[MAJOR] = TAGSFORBRANCH[MAJOR] " " RC;
        TAGSFORBRANCH[MINOR] = TAGSFORBRANCH[MINOR] " " RC;
        BASEBRANCHES[MAJOR] = "T";
    }
    /^ooo\/OOO/ {
        BRANCH=\$0
        sub(/_m[0-9]*\$/,"",BRANCH);
        TAGSFORBRANCH[BRANCH] = TAGSFORBRANCH[BRANCH] " " \$0;
        BASEBRANCHES["ooo/DEV300"] = "T";
    }
    /^ooo\/DEV/ {
        BRANCH=\$0
        sub(/_m[0-9]*\$/,"",BRANCH);
        TAGSFORBRANCH[BRANCH] = TAGSFORBRANCH[BRANCH] " " \$0;
    }
    /^(LIBREOFFICE_|LO-BASE-INTEGRATION-DEV300_|OOO_BUILD_|linux-build-fridrich-20100930|OpenOffice_).*/ {
        if(\$0 ~ /^OOO_BUILD/) {
            BRANCH = "OOO_BUILD";
        } else {
            split(\$0, fields, "_");
            BRANCH = fields[1];
        }
        TAGSFORBRANCH[BRANCH] = TAGSFORBRANCH[BRANCH] " " \$0;
        BASEBRANCHES[BRANCH] = "T";
    }
    END {
        for (BRANCH in BASEBRANCHES) {
            print "create_branch " BRANCH " '" TAGSFORBRANCH[BRANCH] "'";
            delete TAGSFORBRANCH[BRANCH];
        }
        for (BRANCH in TAGSFORBRANCH)
            print "create_branch " BRANCH " '" TAGSFORBRANCH[BRANCH] "'";
    }
EOF

premerge_fixes
ALLMISSINGTAGS=
SKIPPEDTAGS=
SPLITREPOTAGS=`cd $REPODIR/core; git tag|grep bootstrap|sed s/^bootstrap_//`
echo $SPLITREPOTAGS|awk -f $FINDREPOBRANCHES > $TAGSFORBRANCH
cat $TAGSFORBRANCH
echo "SPLITREPOTAGS: $SPLITREPOTAGS"
source $TAGSFORBRANCH
for TAG in $SPLITREPOTAGS
do
    tag_to_notes $TAG
done
rm $FINDREPOBRANCHES $TAGSFORBRANCH $BISECTFUNCTOR
postmerge_fixes
echo "Missing tags: $ALLMISSINGTAGS"
echo "Skipped tags: $SKIPPEDTAGS"

